# تعليمات وكيل BGL3 نحو "التحقق المستمر القائم على البيانات" (Data-Driven Continuous Verification)

هذا الملف يلخّص ما لدينا الآن (قدرات الوكيل الحالية)، ويصف الهدف المنشود، ويضع خطة مراحل واضحة للانتقال إلى نمط التحقق المستمر القائم على البيانات.
للقراءة المرافقة:

- المنطق العام للنظام: `docs/logic_reference.md`
- طبقة الماوس والحركة: `docs/mouse_agent_plan.md`
- أوامر التشغيل المختصرة: `README.md` (قسم أوامر جاهزة للوكيل)

## أولاً: ما هو موجود الآن (الوضع الحالي)

- **تشغيل سيناريوهات UI بصفحة واحدة ومؤشر مرئي**: الوكيل يشغّل سيناريوهات Playwright (YAML) بجلسة متصفح واحدة، مع استكشاف إجباري خفيف لكل صفحة، ومؤشر ماوس مرئي وسلوك حركة بشرية موحّد عبر Motor/hand_profile.
- **حوكمة الحركة والحماية**: جميع أوامر الماوس تمر عبر Motor؛ حارس check_mouse_layer يمنع أي استخدام مباشر لـ page.mouse.*؛ حارس metrics_guard يتحقق من نطاق القياسات؛ رجوع (Back) مسموح فقط كتعافٍ محدود وبسجل أحداث.
- **القياس والتلخيص**: تسجيل runtime_events/learned_events في knowledge.db؛ تلخيص Move→Click و Click→DOM في metrics_summary.json؛ سيناريو dom_change ينتج عينات DOM؛ سكربتات جاهزة (run_ui.ps1، run_ci.ps1) لتشغيل، تلخيص، وحراس.
- **إدراك موضعي واتخاذ قرار قبل النقر**: Policy ينفّذ اقتراب→تقييم موضعي→نقر، يزرع MutationObserver قبل النقر لرصد أول تغيّر DOM، ويعيد ضبط mouse_state.
- **اتساق فلترة بيانات الاختبار والإحصاءات**: Navigation وStats يحترمان Production Mode و exclude_test؛ حذف بيانات الاختبار داخل معاملة مع تنظيف علاقات.
- **توثيق وخطة تشغيل**: mouse_agent_plan, logic_reference محدّثان، وأوامر التشغيل مذكورة في README.

## ثانياً: الهوية والقدرات الحالية للوكيل (Context-Aware Synthetic Operator)

- **استنتاج موضعي**: يحدد صلاحية العناصر للتفاعل، ويغيّر المسار إذا كان العنصر معطّلاً أو محجوباً.
- **كشف تعارض الترشيح**: ينبه عند تقارب درجات المورد/البنك أو تطبيع ضعيف، أو تاريخ مختلف لنفس الاسم الخام.
- **رصد تجربة المستخدم**: يقيس Move→Click وأول تغيّر DOM بعد النقر ويرفع إنذار جودة عند البطء أو الصمت.
- **حوكمة الحركة**: يفرض حركة بشرية موحّدة ويعتبر الخروج عنها فشلاً؛ يمنع النقرات العمياء.
- **ربط زمني**: يحتفظ ببصمة hand_profile للجلسة ويربطها بالقياسات والأحداث لمقارنة التحسن/التدهور بين تشغيلات.

## ثالثاً: الهدف المنشود (Data-Driven Continuous Verification)

- **تعريف مختصر**: حلقة مغلقة تعتمد على بيانات التشغيل الحقيقية للوكيل لتوليد اقتراحات تحسين (فهارس، أعمدة مشتقة، سيناريوهات جديدة، حدود قياس)، تمر عبر بوابة مراجعة، ثم تُختبر في تشغيل مظلّل/كاناري قبل التعميم، وتُغذّي نفسها بالنتائج.
- **سمات الهدف**:
  - Event Lake مركزي أو تجميع دوري للأحداث (UI, API, performance).
  - طبقة تحليل تنتج اقتراحات ملموسة (SQL للفهرسة، سيناريوهات YAML، حدود قياس).
  - Gate بشرية/آلية (PR/Change Request) قبل التطبيق.
  - Canary/Shadow run لإثبات التحسن وعدم كسر السلوك.
  - تقارير دورية تربط UI ↔ DB ↔ الأداء عبر الزمن.

## رابعاً: خطة الانتقال (مراحل التنفيذ)

### المرحلة 0 (جاهزة الآن)

- الاستمرار في تشغيل `run_ci.ps1` بعد كل تعديل، والحفاظ على الحراس (check_mouse_layer، metrics_guard).

### المرحلة 1 (تجميع وتحليل أولي)

- إضافة سكربت تحليل دوري يقرأ knowledge.db ويُخرج:
  - `analysis/index_suggestions.json`: استعلامات بطيئة متكررة → اقتراح أعمدة مشتقة/فهارس.
  - `analysis/coverage.json`: مسارات UI/API غير مغطاة مقارنةً بملفات السيناريو.
  - مسودات سيناريوهات تولَّد إلى `scenarios/generated/` (لا تُشغَّل تلقائياً).
- جدولة تشغيل التحليل (cron/CI) بدون تطبيق التغييرات تلقائياً.

### المرحلة 1.ب (بناء وعي الكود والمنطق - Dynamic First)

- **الأولوية للتتبع الديناميكي (Dynamic Instrumentation)**: بدلاً من الاعتماد الكلي على التحليل الساكن الهش (Regex)، يتم جمع الآثار الحية المسجلة في `runtime_events` لربط UI → Backend.
- **تحليل ساكن تكميلي**: يستخدم فقط لسد الثغرات التي لم يلمسها الوكيل، مع تحديث `route_service_map.json` بحذر.
- **نقاط يجب وضعها في الحسبان**:
  - إمكانية توصيل الأحداث إلى مخزن زمني بسيط (ملف parquet/Kafka مصغّر).
  - تصميم مخطط Feature مبدئي لربط UI events بالاستعلامات.
  - التفكير في آلية تنبيه خفيفة (alert).

> ملاحظة خفض مخاطر: التحليل الساكن وحده قد يكون هشاً؛ الاعتماد على آثار ديناميكية أثناء التشغيل يقلل الكسر عند تغييرات الكود.

### المرحلة 1.ج (نموذج قرار للاقتراحات - Scoring)

- تعريف Score بسيط لكل اقتراح (index/column/scenario/threshold) اعتماداً على:
  - Impact = تكرار الحدث × شدة الألم (latency/fail rate) × قربه من مسار عمل حرج.
  - Confidence = عدد/اتساق الأدلة عبر تشغيلات متعددة.
  - Cost/Risk = نوع التغيير (فهرس بسيط < عمود مشتق < سيناريو يلمس بيانات حساسة).
- المعادلة: `Score = w1*Impact + w2*Confidence - w3*Cost`.
- المخرجات لكل اقتراح: `priority (High/Med/Low)` + `rationale` من 3 أسطر “لماذا”.
- دمج الـ priority في ملفات `index_suggestions.json` و `coverage.json` ووسم مسودات السيناريو.

### المرحلة 2 (بوابة مراجعة وجداول تطبيق)

- إنشاء مسار مراجعة واحد للاقتراحات: توليد ملف SQL للفهرسة وملفات YAML للسنياريوهات مع بطاقة مراجعة.
- ربط `metrics_guard` بحدود قابلة للضبط من CI لتفشل إذا خرجت القياسات عن النطاق بعد أي دمج.

### المرحلة 3 (تشغيل مظلّل/كاناري - Shadow Run)

- إضافة خيار تشغيل سيناريوهات على قاعدة بيانات/بيئة Shadow، وتسجيل قياسات منفصلة.
- **إدارة مخاطر التزامن (Data Sync Risk)**:
  - البدء بـ **Shadow Read-Only**: تشغيل سيناريوهات بحث/تصفية فقط على نسخة مطابقة للأصل لتفادي تعقيدات الكتابة.
  - في حال سيناريوهات الكتابة: يلزم استراتيجية تصفير أو Transactions معزولة لضمان تكافؤ الحالة بين Main و Shadow.
- مقارنة ملخص shadow vs main تلقائياً (metrics_summary + coverage) وإنتاج تقرير فرق (diff) يُرفق بالـ PR.

> ملاحظة خفض مخاطر: ابدأ بـ Shadow Read (قراءة فقط) لتجنب تعقيد تزامن البيانات في سيناريوهات الكتابة، ثم وسّع تدريجياً.

### المرحلة 4 (اختبار الحمل والتزامن - Concurrency & Load)

- **سد فجوة المستخدم الواحد**: الوكيل الحالي (Single User) لا يكشف مشاكل القفل (Database Locking) المذكورة في `Logic Reference`.
- إضافة وضع `metrics_stress`: تشغيل عدة وكلاء (Playwright Workers) بآن واحد على سيناريوهات متضاربة (مثلاً: استيراد وحذف في آن واحد) لكشف `SQLITE_BUSY` أو `no transaction active`.
- توسيع التخزين والتحليل:
  - نقل الأحداث إلى مخزن زمني مركزي (حتى لو محلياً كبداية: SQLite مركزي أو ملف parquet).
  - بناء Feature Store خفيف لميزات متكررة (أبطأ استعلام، أكثر زر استخداماً، مسارات بلا تغطية).

> ملاحظة خفض مخاطر: لا تبدأ بـ Event Lake كامل إذا لم يكن ضرورياً؛ SQLite + ملفات parquet مجدولة قد تعطي نفس القيمة دون عبء منصة.

### المرحلة 5 (تغذية راجعة مغلقة)

- جعل التحليل ينتج توصية مصنّفة (High/Med/Low) مع الثقة، ويغلق الحلقة: تشغيل لاحق يؤكد التحسن أو يتراجع.
- أتمتة تحديث حدود القياس (thresholds) تدريجياً بناءً على بيانات التشغيل، مع بوابة موافقة.

## خامساً: مسؤوليات وحدود مفتوحة

- الحراس (Motor، check_mouse_layer، metrics_guard) غير قابلين للتعطيل في التشغيل المرجعي.
- الضبط والتسريع مسموح عبر متغيرات البيئة وقيم hand_profile، ولا يُعدّ تغييراً للحراس.
- إضافة فهارس/أعمدة أو سيناريوهات جديدة تمر عبر بوابة مراجعة (مرحلة 2).
- يبقى الباب مفتوحاً لأي مطوّر لإضافة تحسينات سرعة/تغطية طالما يلتزم بالحواجز أعلاه.
- تغطية مسار الأعمال الحرِج: يجب إدراج سيناريوهات “استيراد → مراجعة → حفظ” و “إصدار خطاب” مبكراً (ضمن المرحلة 2) لضمان أن القياس يستند لمسارات حقيقية.
- الأمان والخصوصية: تطبيق Redaction بسيط على الأحداث/اللقطات (mask للمعرفات/البريد/الأرقام) وتحديد سياسة احتفاظ للوسائط.
- قيود الموارد: سياسة معدل تشغيل (عدد السيناريوهات/اليوم، إيقاف تلقائي عند استهلاك CPU/RAM مرتفع) تُفعّل قبل تعميم التشغيل الظلي.

> ملاحظة خفض مخاطر: التشغيل الحالي مستخدم واحد؛ لا يزال خطر القفل/التوازي موجود. إضافة تشغيل متزامن محدود قبل الظل الكتابي يقلل المفاجآت.

## سادساً: عقد المخرجات (Artifact Contract)

يعرف كيف يُنتَج كل مخرج آلي، وأين يُحفظ، وكيف يُراجع قبل التطبيق:

- **الموقع والتسمية**: كل مخرج تحليلي في `analysis/`، كل ملخص قياس في `.bgl_core/brain/*.json`، والمسودات في `scenarios/generated/`. الأسماء واضحة (index_suggestions.json, coverage.json, metrics_summary.json, index_patch.sql).
- **البنية الدنيا**:
  - `index_suggestions.json`: [{ "query": string, "suggested_index": string, "confidence": 0..1, "evidence": [...] }]
  - `coverage.json`: [{ "route": string, "status": "uncovered|partial", "evidence": [...] }]
  - `metrics_summary.json`: { move_to_click_ms: {...}, click_to_dom_ms: {...} }
  - `index_patch.sql`: أوامر CREATE/ALTER بدون تنفيذ تلقائي.
  - مسودات السيناريو: YAML بصفحة واحدة، meta حقل `generated: true`.
- **التحقق**: كل ملف يمرر JSON lint/Schema بسيط (مفتاح موجود، أنواع صحيحة). أي خطأ يمنع دخوله في بوابة المراجعة.
- **المراجعة والتطبيق**: لا يُطبّق SQL أو يُضاف سيناريو للتشغيل المرجعي إلا عبر مراجعة (PR/Change Request) مع إرفاق الأدلة والملخصات. الحراس (metrics_guard, check_mouse_layer) يبقون إلزاميين بعد الدمج.

## سابعاً: مقاييس النجاح العملية

- **التغطية والحماية**: مساران حرجيان مفعّلان (استيراد→مراجعة→حفظ، إصدار خطاب)؛ صفر اختراق لـ check_mouse_layer و metrics_guard في كل CI.
- **الأداء والتجربة**: Move→Click p50 ضمن نطاق مستهدف (مثلاً 2500–4500 ms) مع تنوّع (p90/p50 > 1.2)؛ عينات Click→DOM لكل تشغيل CI (count ≥ 3، p50 < 300 ms).
- **جودة الاقتراحات (Scoring)**: كل اقتراح يحمل priority ورationale؛ 80% من High تُراجع في دورة واحدة؛ تحسن ملحوظ بعد التطبيق (مثلاً -20% زمن استعلامات بطيئة أو +10% تغطية مسارات).
- **حلقة الظل/الكاناري**: مقارنة shadow/main أسبوعياً؛ تقرير diff مرفق بكل PR يؤثر على الأداء/الفهارس؛ لا فروق سلبية حرجة قبل الدمج.
- **صحة البيانات والأمان**: Redaction 100% للأحداث/اللقطات؛ سياسة احتفاظ مفعّلة ومكتوبة.
- **استقرار التشغيل**: فشل بسبب موارد < 5% من التشغيلات؛ احترام سقف السيناريوهات/اليوم مع إنذار عند التجاوز.
