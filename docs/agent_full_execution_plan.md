# خطة التنفيذ الكاملة لوكيل BGL3 (المتبقي فقط)

**التاريخ:** 2026-02-09  
**الهدف:** وكيل يعمل كـ “بلوق حي” لمشروع قائم: يفهمه بالكامل (كود + واجهة + سلوك runtime)، يكتشفه ويستخرج منطقه، يصلحه ويحسّن أداءه، ويقيس أثر كل تغيير بدقة.  
**اتفاق الإنهاء:** عند اكتمال هذه الخطة وتحقيق معايير DoD، يُعتبر الوكيل **جاهزًا** ولا تُجرى أي تطويرات إضافية إلا بطلب جديد صريح.

**ملاحظة مهمة:** هذه النسخة تحتوي فقط البنود غير المنجزة أو التي تحتاج تحقق تشغيلي. البنود المنجزة أزيلت من الخطة لتجنب التكرار.

---

## حالة مختصرة (بدون تشغيل فحوصات جديدة)
- **context_digest** كان يتأخر/يفشل بسبب المهلة؛ تم تقليل الحمل لكن يحتاج ضمان استمرارية.
- **success_rate** أقل من الهدف المطلوب في DoD.
- **السجل السببي** تحسّن (decision_traces + عرض بالـ report) لكن يحتاج تثبيت كامل ووضوح الربط.
- **حلقة التعلّم الذاتية** تحتاج ضمان استمرارية بلا انقطاع.
- **سياسة الأهداف طويلة المدى** تحتاج ترتيب/جدولة أدق وربط أقوى بالاستكشاف.

---

## البنود المتبقية (حسب ترقيم الخطة الأصلية)

### 3) تثبيت طبقة التشغيل (Timeouts/Guards)
**الوضع الحالي:** توجد timeouts لكن فعاليتها التشغيلية ليست مؤكدة في كل المسارات.  
**الربط الحالي:** `step_timeout_sec` و`scenario_batch_timeout_sec` موجودان، وسجل timeouts يظهر في `runtime_events`.  
**المتبقي:** تحقق تشغيلي يثبت أن التعليق الصامت يُغلق فعليًا، وأن الأقفال تُنعش أثناء التشغيل الطويل بدون توليد تعارضات.  
**الأثر المتوقع:** تقليل التعليق الصامت ورفع موثوقية نتائج الفحص.


---

## Definition of Done (إنهاء مرحلة بناء الوكيل)
**الهدف:** تحديد نهاية عملية البناء بحيث تكون قابلة للقياس وليست شعورية.
**الربط الحالي:** المؤشرات تظهر في `latest_report.json` عبر `guardian.py` و`master_verify.py`.

1. **نجاح التنفيذ:** `execution_stats.success_rate` ≥ 0.75 لمدة 7 أيام متواصلة.
2. **عدم التعليق الصامت:** `scenario_run_stats.status` لا تُسجل `skipped` بدون سبب مرفق، و`scenario_step_timeout` < 3% من إجمالي الخطوات.
3. **تغطية تشغيلية حقيقية:**
   أ) `ui_action_coverage.coverage_ratio` ≥ 30% على الأقل في مسارات الواجهة الأساسية.
   ب) `flow_coverage.covered_flows` ≥ 60% مع وجود `events` حقيقية لكل Flow مغطّى.
4. **Gap Loop يعمل بالكامل:**
   أ) `gap_scenarios` تُولد وتُنفّذ تلقائيًا خلال 24 ساعة من اكتشاف gap.
   ب) `gap_changed` > 0 في آخر 7 أيام.
5. **أثر دلالي فعلي:** `ui_semantic_delta.changed` يظهر في ≥ 50% من جلسات الاستكشاف خلال 7 أيام.
6. **تعلم مستمر قابل للقياس:**
   أ) `proposals` > 0 أسبوعيًا بدون تدخل يدوي.
   ب) وجود أثر واضح بين proposal → sandbox → measurement → policy update.
7. **Canary/Rollback فعّال:**
   أ) `canary_status.evaluated` > 0 أسبوعيًا.
   ب) rollback يحدث تلقائيًا عند تدهور مؤشرات الأداء.
8. **External Dependency لا يوقف الحلقة بالكامل:**
   أ) نسبة `failure_taxonomy.by_class.blocked` < 30% في آخر 24 ساعة.
   ب) عند تعطيل fallback كليًا تُستبدل هذه النقطة بمؤشر انخفاض أخطاء الاعتمادات الخارجية أو نجاح إعادة المحاولة.
9. **ثبات القرار:**
   أ) `diagnostic_delta.changed_keys` يعكس تغيّرات واقعية عند تغيّر النظام.
   ب) لا يوجد تضارب في `expected_failures` لأكثر من 48 ساعة.
10. **سجل موحد ومقروء:**
    أ) القرار + النتيجة + الفشل + الأثر في سجل واحد يمكن الاستعلام عنه.
    ب) التقرير يعرض سبب القرار والبدائل والأثر المتوقع بوضوح.

---

## فصل مساري التحسين (Self vs Project)
**الهدف:** فصل تحسين سلوك الوكيل عن تحسين المشروع نفسه، مع تفعيل تلقائي آمن للمشروع بعد تحقق DoD.
**الربط الحالي:** مفاتيح التحكم موجودة في `.bgl_core/config.yml` وتطبيق القرارات يمر عبر `authority.py` و`apply_proposal.py`.

### مسار 1: تحسين الوكيل (Self-Improvement Loop)
**النطاق:** منطق الاستكشاف، القياس، التعلم، السياسات، التغطية، الجداول.  
**المسموح دائمًا:** تحديث قواعده الداخلية، تعديل استراتيجيات الاستكشاف، تحسين السجل السببي.  
**لا يغيّر:** ملفات المشروع الإنتاجية أو منطق النظام الفعلي.

### مسار 2: تحسين المشروع (Project-Autonomy Loop)
**النطاق:** تطبيق اقتراحات على ملفات المشروع مع التقييم والـ rollback.  
**الحالة الافتراضية:** مغلق حتى تحقق DoD بالكامل.  
**التمكين بعد DoD:** يُفتح تلقائيًا وفق بوابة واضحة.

---

## طبقة “ذكاء الكود والزمن” (Code Intelligence & Temporal Reasoning)
**الهدف:** جعل الوكيل يفهم “كيف يعمل النظام” وليس فقط “ماذا يفعل”.

### C4) اختبار ما بعد التعديل مرتبط بالسياق
**المتبقي:** تحقق تشغيلي يثبت أن الاختبارات تُختار حسب الملفات المتغيرة وتُربط نتائجها بالسجل السببي.

### C5) تحليل أداء فعلي (Runtime Profiling)
**المتبقي:** تحقق تشغيلي يثبت أن زمن الاستجابة يُقاس ويُعرض بشكل دوري في التقارير.

### C6) طبقة تعديل آمنة للكود (Safe Patch Intelligence)
**المتبقي:** تحقق تشغيلي يثبت أن قرار التعديل يُراعي مخاطر الزمن/الاستدعاء ويؤثر على الترويج/الرجوع.

---

## توضيح ختامي بعد تنفيذ الخطة
بعد اكتمال هذه الخطة، سيصبح الوكيل قادرًا على **تشخيص ومعالجة معظم مشاكل المشروع تلقائيًا** عبر حلقة ذاتية (اقتراح → تنفيذ → قياس → تعلّم).  
لكن **ليس كل مشكلة** ستكون قابلة للحل ذاتيًا، وبشكل خاص في الحالات التالية:
1. أعطال خارجية (قواعد بيانات، شبكات، مزودات خارجية).
2. قرارات معمارية كبيرة أو تغييرات تمس منطق الأعمال وتتطلب قرارًا بشريًا.
3. مشاكل تحتاج بيانات إنتاجية حساسة أو صلاحيات غير متاحة للوكيل.

---

## دليل تنفيذ المطوّر (Developer Execution Guide)
**الهدف:** تمكين أي مطوّر من تنفيذ البنود المتبقية دون الرجوع لمحادثات سابقة.

### 1) تجهيز البيئة
- Python 3.14
- Playwright + Chromium
- قاعدة بيانات `.bgl_core/brain/knowledge.db` قابلة للكتابة
- صلاحيات كتابة على `.bgl_core/logs`
- تشغيل الواجهة محليًا

### 2) مصادر الحقيقة والملفات المرجعية
- `.bgl_core/logs/latest_report.json`
- `.bgl_core/config.yml`
- `.bgl_core/brain/master_verify.py`
- `.bgl_core/brain/run_scenarios.py`
- `.bgl_core/brain/authority.py`
- `.bgl_core/brain/apply_proposal.py`
- `.bgl_core/brain/canary_release.py`

### 3) قواعد السلامة أثناء التنفيذ
- **لا يتم تشغيل فحوصات/تشخيصات جديدة إلا بعد موافقة صريحة من صاحب المشروع.**
- التعديل على المشروع يتم في sandbox أولًا.
- لا يُفتح الإنتاج تلقائيًا إلا بعد تحقق DoD.

### 4) منهجية تنفيذ أي بند متبقٍ
1. سجّل baseline من `latest_report.json` (وقت + المؤشرات الأساسية).
2. **فعّل capability موجودة** بدل بناء جديد حيثما أمكن (تمكين + ربط + قياس).
3. نفّذ **دفعة تغييرات مترابطة** تخدم capability واحدة فقط (لتجنّب تداخل الأسباب).
4. عند الحاجة للتشغيل، اطلب موافقة صريحة أولًا.
5. قارن المؤشرات الأساسية قبل/بعد.
6. إذا تحسن المؤشر المطلوب وثبت، اعتبر البند منجزًا.

### 5) منهجية التمكين بدل التدخّل
**القاعدة:** لا نقوم بـ “حقن حلول” مباشرة، بل نُنشّط قدرات الوكيل الموجودة أصلًا ونربطها بقياس واضح.  
**نُسمح بالتدخل اليدوي فقط في حالتين:**
1. فتح مسار تعلّم جديد (تمكين capability كانت معطّلة أو غير مربوطة).
2. منع تعطّل الحلقة (Safety/Recovery).

**ما الذي يعنيه “تمكين capability” عمليًا؟**
- تشغيل الفلاج المناسب (إن كان معطّلًا).
- ربط القدرة بمصدر بيانات واضح (events/snapshots/flows).
- ربطها بمؤشر قياس سببي في التقرير.

### 6) توسيع القدرات لتشمل الأتمتة (Automation Capabilities)
**المبدأ:** أي Capability يجب أن تكون قابلة للأتمتة (Self‑Automation) لا أن تبقى مجرد مسار يدوي.  
هذا يعني أن “القدرة” لا تُعتبر مكتملة إلا إذا أصبح لها **حلقة تلقائية**: اكتشاف → تخطيط → تنفيذ → قياس → تصحيح.

**أمثلة قدرات أتمتة موجودة بالفعل (تمكينها وربطها):**
- **Auto‑Digest**: `auto_digest`, `auto_digest_hours`, `auto_digest_limit`
- **Auto‑Propose**: `auto_propose`, `auto_propose_min_conf`, `auto_propose_min_evidence`
- **Auto‑Plan**: `auto_plan`, `auto_plan_limit`
- **Auto‑Apply (Sandbox)**: `auto_apply`, `auto_apply_limit`, `auto_apply_timeout_sec`
- **Auto‑Verify**: `auto_verify`, `auto_verify_on_low_success`
- **Auto‑Run Scenarios After Apply**: `auto_run_scenarios_after_apply*`
- **Auto‑Run Gap Scenarios**: `auto_run_gap_scenarios`, `gap_scenario_run_limit`
- **Self‑Heal**: `auto_self_heal`, `self_heal_toggle_limit`
- **Canary/Rollback**: `canary_auto_rollback`, `post_apply_auto_rollback_on_fail`
- **Memory Automation**: `memory_auto_curate`, `memory_auto_merge`, `memory_auto_split`

**معيار النجاح:**  
القدرة تُعتبر “مفعّلة” فقط إذا أثمرت **سجلًا سببيًا** واضحًا و**مؤشرًا في التقرير** يثبت أن الأتمتة تعمل دون تدخل بشري.

**قاعدة صارمة:**  
لا تُذكر أي قدرة على أنها “متاحة” ما لم تكن **موجودة فعليًا في الكود/الإعدادات**.  
أي قدرة غير موجودة تُعامل كبند تطوير (غير متاح) ولا تُعرض كميزة حالية.
