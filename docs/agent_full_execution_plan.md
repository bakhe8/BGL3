# خطة التنفيذ الكاملة لوكيل BGL3 (منظمة ومحدّثة)

**التاريخ:** 2026-02-10  
**الهدف النهائي:** وكيل يعمل كـ “بلوق حي” لمشروع قائم: يفهم الكود والواجهة والسلوك runtime، يكتشف الفجوات، يقترح الإصلاحات، ينفّذها بأمان، ويقيس الأثر بدقة.  
**اتفاق الإنهاء:** عند تحقق معايير DoD كاملة، يُعتبر الوكيل جاهزًا ولا تُجرى تطويرات إضافية إلا بطلب جديد صريح.

---

## 1) الوضع الحالي (مختصر بناءً على آخر تقرير)
**مرجع التقرير:** `latest_report.json` بتاريخ 2026-02-10 12:59  
- **success_rate:** 0.593 (أقل من هدف DoD 0.75).  
- **context_digest:** يعمل (ok=true) ويُسجّل خبرات، مع تخطي curation عند ضيق الميزانية.  
- **ui_action_coverage:** 19.53% (تشغيلي ومُعتمد لكنه أقل من هدف DoD 30%).  
- **flow_coverage:** 40% (sequence) مع **operational_coverage_ratio = 100%** (أي يوجد تشغيل فعلي لكن التغطية المنهجية ناقصة).  
- **ui_semantic_delta:** 0 (لا تغيّر دلالي مُسجّل بعد).  
- **gap_scenarios:** موجودة وقائمة (يتم توليدها وتشغيلها) لكن ما زال أثرها على التغطية غير كافٍ.  
- **scenario_run_stats:** آخر تشغيل حالته `fail` و `event_delta=0` (يعني دفعة تشغيل لم تنتج أحداث داخل السياق).  
- **canary_status:** evaluated = 1 (بدأت تعمل فعليًا).  
- **diagnostic_status:** ما زال يظهر `running` رغم وجود تقرير مكتمل (علامة على أن حالة الفحص تحتاج تنظيف نهائي عند الإنهاء).
- **طبقة اختيار السيناريوهات الذكية:** مفعّلة + Auto‑Budget نشط (تعديل ذاتي للأوزان/الصرامة والميزانية).

---

## 2) مبادئ التنفيذ (غير قابلة للتجاوز)
- لا يتم تشغيل أي فحوصات/تشخيصات جديدة إلا بعد موافقة صريحة من صاحب المشروع.
- التغيير يُفعّل عبر القدرات الموجودة أولًا قبل بناء جديد.
- الربط يكون **شاملًا عبر الذاكرة** وليس فقط عبر التقرير.
- أي نتيجة جزئية تُوسم بوضوح حتى لا تُقرأ كنهائية.

---

## 3) خطة توحيد تنفيذ الفحوصات + ربطها بالذاكرة (محور تشغيل جديد)

**الهدف:** تشغيل آلي بدون انتظار يدوي، مع تمييز الجديد عن القديم، وربط ذلك بذاكرة الوكيل وفهمه.

### 3.1 النقاط الخمس الأساسية (تنفيذ موحّد)
1) **تشغيل مجدول + سجل حالة التشغيل**  
   - **تم:** سجل حالة تشغيل مركزي عبر `diagnostic_status.json` (running/cached/timeout/complete).
2) **تقرير مرحلي (Checkpoint)**  
   - **تم:** `diagnostic_checkpoint` في `runtime_events` (profile/scenarios/route_scan).
3) **فحص سريع تلقائي + فحص كامل دوري**  
   - **تم برمجيًا:** وضع `fast` يعمل بمسح محدود (scan) بدل التعليق/الـ stub.
4) **إشعار اكتمال الفحص**  
   - **تم:** `diagnostic_run_complete` + تحديث status.
5) **Auto-timeout + تقرير جزئي**  
   - **تم:** budget داخل `guardian` + fallback على تقرير مخزّن عند timeout.

### 3.2 دلتا واضحة (الجديد vs القديم)
- **تم:** مقارنة تلقائية بين آخر تقريرين داخل `diagnostic_comparison`.
- تصنيف التغيّر: `improvement`, `regression`, `noise`.
- **تم:** حفظ baseline مستقل (Full فقط) + مقارنة baseline داخل التقرير.

### 3.3 تمكين الضبط الآمن لحدود الفحوصات (الوقت/المسارات/السيناريوهات)
- تمكين الوكيل من ضبط:
  - `diagnostic_timeout_sec`
  - `route_scan_limit`
  - `route_scan_max_seconds`
  - `scenario_batch_limit`
- التعديل يتم عبر **مسار آمن** فقط: `storage/agent_flags.json`.
- التعديل يعتمد على نتائج التشغيل السابقة (مدة الفحص، نسبة النجاح، نسبة التوقف).
  - **تم:** عبر `config_tuner.py` (SAFE_KEYS).

### 3.4 ربط الفحوصات بمسار الذاكرة والفهم
- تسجيل أحداث الفحوصات في `runtime_events`:
  - `diagnostic_run_started`
  - `diagnostic_checkpoint`
  - `diagnostic_run_complete`
  - `diagnostic_delta`
- تحويل هذه الأحداث تلقائيًا عبر `context_digest` إلى Experiences.
- ربطها بـ `decision_traces` كي يقرأ الوكيل أثرها عند التخطيط أو التصحيح.
  - **تم:** الأحداث + التحويل عبر `context_digest.py` + `decision_traces`.

### 3.5 طبقة حماية الفحوصات (منع الأخطاء غير المقصودة)
- **تم:** تأجيل الفحص تلقائيًا عند نشاط المستخدم (`diagnostic_idle_guard_sec`).
- **تم:** كشف الإنهاء القسري وتحويله إلى `aborted` بدل نتائج مضللة.
- **تم:** عدم تحديث baseline إلا عند ثقة كافية (`diagnostic_confidence >= 0.7`).
- **تم:** تشغيل الخلفية بدون نافذة عبر daemon.

### 3.6 تصنيف أخطاء الفحوصات (Fault Taxonomy)
- **تم:** إضافة `diagnostic_faults` مع أسباب واضحة (timeout/aborted/low_events/low_coverage).
- تُسجَّل للوكيل ضمن snapshots حتى لا يبني قرارات على فحص معيوب.

### 3.7 طبقة اختيار ذكية للسيناريوهات (Scenario Scheduler)
- **تم:** طبقة اختيار تعتمد على نتائج التشغيل السابقة بدل تشغيل دفعة ثابتة.  
- **تم:** ضبط ذاتي للصرامة/الأوزان والـ cooldown حسب معدلات الفشل.  
- **تم:** ربط “الوقت الضائع” بميزانية تشغيل تلقائية (Auto‑Budget).  
- **مخرجاتها:** `scenario_selection.json` + إدراج selection ضمن Scenario Run Stats.

---

## 4) البنود المتبقية من الخطة الأصلية (مرتبة حسب الأثر)

### 4.0 ترتيب الأولويات المتبقية (مختصر وواضح)
1) **رفع UI Action Coverage** من 19.53% إلى ≥ 30% (شرط DoD أساسي).  
2) **رفع Flow Coverage (sequence)** من 40% إلى ≥ 60% مع أحداث فعلية.  
3) **تفعيل Semantic Delta** (الوضع الحالي 0) لإثبات تغيّر دلالي بعد الاستكشاف.  
4) **تصحيح موثوقية تشغيل السيناريوهات** عند ظهور `event_delta=0` لضمان أن كل تشغيل يترك أثرًا.  
5) **استمرار قياس النجاح** ورفع success_rate إلى ≥ 0.75.  
6) **Canary/Rollback**: بدأ لكنه يحتاج بيانات تشغيلية أكثر لثبات القرار.

#### 4.0.1 تحديثات برمجية منفّذة الآن (بدون تشغيل فحوصات)
- **Semantic Delta**: تم تفعيل دلتا عبر مقارنة آخر Snapshot مع أي Snapshot سابق (حتى عبر URL مختلف) + وسم `new_url` عند ظهور صفحة جديدة.  
- **UI Action Coverage**: تم تسجيل محاولات التفاعل التي لم تغيّر الـ DOM كـ `no_change` داخل `exploration_novelty` لرفع التغطية الواقعية وتقليل التكرار.  
- **Flow Sequence Coverage**: تم إضافة **Sequence Inference** عبر الجلسات (مع الحفاظ على القياس الصارم)، وإرجاع نسبتين: strict + inferred.  
- **Scenario Run Reliability**: تم احتساب أحداث fallback عند قفل قاعدة البيانات (`runtime_events_fallback.jsonl`) وربطها بـ `event_delta_total` بدل قراءة 0 مضللة.  
- **UI Gap Scenarios (ثبات أعلى)**: تم تمرير `selector_key` و`needs_hover` داخل فجوات UI وتوليد محددات أكثر ثباتًا + hover اختياري قبل النقر.  
- **Scenario Batch Timing**: تم تسجيل `scenario_batch_start/complete` مع مدة التنفيذ وإدراج `scenario_batch_duration_s` في التقرير لتحديد زمن التعليق بدقة.  

> **مهم:** هذه التعديلات مفعّلة برمجيًا، وتحتاج **تحقق تشغيلي واحد** لإثبات أثرها في التقرير.

### 4.1 ثبات التشغيل والقياس
> هذه البنود مفعّلة برمجيًا، لكن التقرير الأخير أظهر حالة `event_delta=0` في آخر دفعة، لذلك يجب تثبيت موثوقية التشغيل.

- **Timeouts/Guards تشغيلية:** تعمل لكن يجب ربطها بالسبب التشغيلي عند فشل الدفعة.  
- **C4 اختبار سياقي بعد التعديل:** مفعّل برمجيًا ويحتاج تحقق عند التشغيل الكامل.  
- **C5 Runtime Profiling:** مفعّل ويحتاج ثبات في تسجيل القياسات.  
- **C6 Safe Patch Intelligence:** مفعّل ويحتاج بيانات تشغيلية كافية لتأثير فعلي على القرار.

### 4.2 تغطية الاستكشاف (نتائج فعلية من التقرير)
- **UI Action Coverage**: 19.53% (تشغيلي ومُوثّق) — **ما زال أقل من الهدف**.  
- **Flow Coverage**: 40% (sequence) / 100% (operational) — **النقص في sequence coverage ما زال قائمًا**.  
- **Gap Loop**: يعمل (gaps موجودة وتُشغَّل) لكن تأثيرها على UI coverage ما زال ضعيفًا.  
- **Semantic Delta**: 0 — **لم يتحقق بعد** ويحتاج استكشاف يولّد تغيّرًا دلاليًا فعليًا.

### 4.3 Loop & Canary
- **Proposals مستمرة**: موجودة لكن العدد منخفض (آخر تقرير: 1) — تحتاج ثبات تشغيل لتكثيف التوليد.  
- **Canary/Rollback**: بدأ يعمل (evaluated=1، rollback=1) — يحتاج بيانات تشغيل متسقة لتثبيت القرار.

---

## 4.4 ما تبقّى فعليًا الآن (تشغيلي فقط)
- **تثبيت تشغيل السيناريوهات** بحيث لا يظهر `event_delta=0` في دفعات التشغيل.  
- **رفع UI Action Coverage** عبر تشغيل موجّه للعناصر غير المُغطّاة (بدون تكرار غير مفيد).  
- **رفع Flow Coverage (sequence)** عبر ربط gaps مباشرة بتسلسل خطوات flow.  
- **إنتاج Semantic Delta** عبر استكشاف يولّد تغيّرًا دلاليًا حقيقيًا.

---

## 4.5 خطة تشغيل تحقق واحدة (عند الموافقة)
**الهدف:** إثبات أن البنود التشغيلية تعمل كما هو متوقع، دون تشغيل متكرر أو طويل.

1) تشغيل تقرير واحد فقط (full diagnostic) بعد الموافقة.  
2) استخراج المؤشرات التالية من `latest_report.json`:  
   - `ui_action_coverage.operational_coverage_ratio`  
   - `flow_coverage.operational_coverage_ratio`  
   - `ui_semantic_delta.changed` + `change_count`  
   - وجود `gap_coverage_refresh` في runtime_events  
3) مقارنة النتائج قبل/بعد في `diagnostic_comparison`.

---

## 5) Definition of Done (DoD)
**الهدف:** تعريف نهاية البناء بمؤشرات واضحة.

1) success_rate ≥ 0.75 لمدة 7 أيام متواصلة  
2) لا skipped بدون سبب، و timeouts < 3%  
3) ui_action_coverage ≥ 30%  
4) flow_coverage ≥ 60% مع events حقيقية  
5) gap loop يعمل بالكامل خلال 24 ساعة  
6) semantic_delta يظهر في ≥ 50% من الجلسات  
7) proposals أسبوعية مع أثر واضح  
8) canary_evaluated > 0 أسبوعيًا + rollback تلقائي  
9) blocked < 30% أو مع بديل قياس  
10) سجل موحّد واضح في القرار والنتيجة والأثر

---

## 6) فصل مساري التحسين (Self vs Project)

### مسار 1: تحسين الوكيل (Self-Improvement Loop)
- تحديث السياسات والاستكشاف والتغطية والقياس.
- لا يغيّر ملفات المشروع الإنتاجية.

### مسار 2: تحسين المشروع (Project Loop)
- تطبيق الاقتراحات على ملفات المشروع.
- يبدأ فقط بعد تحقق DoD كامل.

---

## 7) دليل التنفيذ لأي مطوّر

### 7.1 مصادر الحقيقة
- `.bgl_core/logs/latest_report.json`
- `.bgl_core/config.yml`
- `storage/agent_flags.json`
- `.bgl_core/brain/master_verify.py`
- `.bgl_core/brain/guardian.py`
- `.bgl_core/brain/authority.py`
- `.bgl_core/brain/apply_proposal.py`

### 7.2 خطوات تنفيذ أي بند
1) سجل baseline من التقرير الحالي.
2) فعّل capability موجودة بدل بناء جديد.
3) نفّذ دفعة تغييرات تخدم capability واحدة فقط.
4) عند الحاجة للتشغيل: اطلب موافقة صريحة.
5) قارن المؤشرات قبل/بعد.

### 7.3 طريقة العمل (ترتيب ثابت لمنع التشعب)
1) **حدد البند + مخرجاته**: ما الذي يجب أن يظهر في التقرير/السجل؟
2) **تحقق من المسار الحالي**: هل البنية موجودة أم ناقصة؟
3) **نفّذ التفعيل بأقل تعديل ممكن**.
4) **وثّق الأثر المتوقع** في نفس البند (حتى لو لم تُشغّل فحوصات).

### 7.4 ربط تلقائي مع ما سبق
- كل بند يجب أن يُظهر أثره في:
  - `runtime_events` (حدث واضح).
  - `decision_traces` (سبب القرار).
  - `latest_report.json` (قراءة التقرير).

### 7.5 منع بناء جديد غير ضروري
- أي تعديل يجب أن يمر عبر سؤالين قبل التنفيذ:
  1) هل يوجد مكوّن موجود يمكن تفعيله بدل بناء جديد؟
  2) هل يوجد جزء من الخطة الحالية يغطي نفس الهدف؟

---

## 8) توضيح ختامي
بعد اكتمال هذه الخطة، سيصبح الوكيل قادرًا على **تشخيص ومعالجة معظم مشاكل المشروع تلقائيًا** عبر حلقة ذاتية.  
لكن بعض الحالات ستبقى تتطلب تدخلًا بشريًا (شبكات خارجية، قرارات معمارية كبيرة، بيانات إنتاج حساسة).
