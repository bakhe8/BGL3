# خطة تطوير وكيل الماوس (من مرحلة الترقيع إلى الإدراك)

## 1) الوضع الحالي (مرحلة A: ترقيع إدراكي)
- Playwright هو المنفذ؛ القرار يُتخذ مسبقاً (اختيار selector) ثم تُعرض حركة ماوس سلسة (smooth_move) لتسهيل المشاهدة.
- الحركة الحالية تفيد في الفيديوهات وقياس الأداء البصري، لكنها لا تغيّر منطق القرار ولا تُسهم في الإدراك.
- الاستكشاف الإجباري موجود لكنه يمكن تعطيله (BGL_EXPLORATION)، والزمن الكلي لجلسة كاملة طويل بسبب كثرة السيناريوهات.
- هذا الحل مؤقت/Instrumentation فقط، قابل للإزالة، والغرض منه إزالة “إحساس الماوس الخفي” واستقرار أرضية القياس.

## 2) خطة التحول إلى حلقة قرار حقيقية (B)
الهدف: إعادة ترتيب الحلقة إلى **استكشف → اقترب → قيّم → قرر** وجعل الماوس جزءاً من الإدراك.

### 2.0 الفصل إلى طبقات واضحة
- Perception (رؤية): Screenshot اختياري + مقاسات viewport + ملخص موضعي للهدف، جار قريب، عنوان/heading قريب، وسبب اختيار الهدف. لا تفريغ كامل للصفحة.
- Policy (قرار): يختار الخطوة التالية بناءً على الحالة/السيناريو كـ hint، ويتعامل مع `mouse_state`.
- Motor (يد): يحول أوامر الحركة إلى مسار بشري (تسارع/تباطؤ، micro-corrections، jitter من hand_profile) ويعيد حالة الوصول. **أي حركة ماوس خارج Motor مرفوضة**.
- hand_profile: يُولد مرة عند بدء الجلسة، يبقى ثابتًا طوال الجلسة، ويتغير بين الجلسات فقط.

### 2.1 طبقة إدراك الماوس
- إضافة حالة داخلية: `mouse_state ∈ {idle, approaching, at_target, invalid_target}`, مع `target_hint`, `last_mouse_pos`.
- دالة `approach(target)` تحرك الماوس فقط (smooth_move) وتنتهي بـ `at_target`. إذا فشل الوصول/الظهور ➜ `invalid_target` ثم تبديل الفرضية (لا تعليق).
- دالة `decide_at_target()` تقييم موضعي: نص العنصر، enabled/disabled، aria/role، bounding box/visibility + parent/heading قريب. لا لقطة DOM كاملة إلا عند فشل غير مفسَّر.
- أي click/press يحدث فقط من حالة `at_target` وبعد انتظار قصير (60–80ms).

### 2.2 الاستكشاف منخفض الكلفة
- تفاعل استكشافي واحد لكل صفحة فقط (آمن): scroll صغير + تحريك إلى منطقة فارغة، أو hover على عنصر محايد (ليس زر تنفيذ). تسجيل “ماذا تعلّم” في learned_events.tsv.
- تعطيل أو تفعيل عبر `BGL_EXPLORATION`.

### 2.3 إدارة السياق
- صفحة واحدة ثابتة؛ لا cleanup أثناء الجلسة. إذا أُغلقت الصفحة تُعاد مرة واحدة مع إعادة حقن المؤشر.
- لا عودة للمنتصف بعد goto؛ يبدأ من آخر موضع معروف أو من الهدف نفسه.

### 2.4 الحركة (نسبيّة وديناميكيّة)
- `smooth_move` يعتمد على طول المسار نسبةً إلى قطر الشاشة: مسارات قصيرة تُنفَّذ بخطوة أو خطوتين سريعتيْن؛ المسارات المتوسطة بعدد خطوات منخفض؛ المسارات الطويلة تُقسَّم إلى محطتين أو أكثر حسب النسبة من قطر الشاشة.
- سرعات الحركة تُشتق من hand_profile (سرعة أساسية + نطاق تباين)، لا أرقام ثابتة.
- تحسين فيزيائي للـ Motor: منحنى سرعة (تسارع ثم تباطؤ) يُقاس زمنه كنسبة من طول المسار، micro-corrections صغيرة كنسبة من البعد، jitter مرتبط بهوية اليد، hesitation قصير قبل عناصر خطرة بدون قيم مطلقة.

### 2.5 القياس
- خط أساس: زمن أول حركة، زمن بين الحركة والنقر، زمن تغيير DOM بعد النقر.
- سجل في runtime_events و learned_events.
- تشغيل يومي مختصر (سيناريو واحد) للقياس؛ تشغيل كامل عند الحاجة فقط.

### 2.6 حوكمة الكود
- أي كود لا يخدم الانتقال إلى الحلقة الجديدة يُرفض (تحسين بصري بلا تغيير قرار = مرفوض).
- توثيق الحالة في `docs/logic_reference.md` مع رابط لهذه الخطة.

## 2.7 معايير القبول
### مرحلة A (ترقيع إدراكي)
- لا قفز مرئي قبل النقر (move → delay قصير → click).
- المؤشر الظاهر يطابق نقطة النقر دائماً.
- زمن الحزمة مستقر وتحت سقف متفق عليه.

### مرحلة B (حلقة القرار)
- في كل صفحة يوجد قرار واحد على الأقل تغيّر بسبب تقييم عند الهدف (مثال: اكتشف زر disabled فغيّر المسار).
- نسبة الأفعال التي جاءت من “اقترب ثم قيّم ثم قرر” أعلى من “click مباشر”.
- learned_events تحتوي اكتشافات غير مكررة وليست فارغة.
- تنوع الحركة: لنفس المسافة/الهدف لا تتطابق المسارات والزمن تمامًا (التنوع داخل hand_profile).
- تصحيح بشري: في نسبة من الحركات الطويلة يظهر overshoot صغير ثم correction أو hesitation قبل عناصر خطرة.

## 3) الهدف النهائي
- وكيل يقرر أثناء الاستكشاف: الحركة تقود الانتباه، القرار يُتخذ عند الوصول/الرؤية، التنفيذ نتيجة وليس سبباً.
- السيناريو دليل طريق (مرجع ثانوي)، لا سكة تنفيذ.
- الماوس جزء من الإدراك (النظر/التجربة) لا مجرد تمثيل بصري للقرار.

## 4) خطوات التنفيذ القريبة (أولوية)
1) دمج طبقة `approach/decide_at_target` في `scenario_runner` بحيث يمر أي فعل عبر الحارس الوحيد `mouse_state=at_target` (وضع `mouse_ready` مُلغى).
1.1) استبدال الحارس الثنائي بـ mouse_state (idle/approaching/at_target/invalid_target) مع مسارات تعافي عند invalid_target.
2) استكشاف واحد لكل صفحة (آمن) وتسجيل التعلم.
3) منع العودة للمنتصف وإبقاء smooth_move القصير مع تقسيم المسافات الطويلة حسب الشاشة.
4) تشغيل سيناريو واحد (home_index) للتحقق من السلاسة وتدوين أزمنة move→click و click→DOM، ثم إعادة تفعيل الاستكشاف تدريجياً.

## 5) خارطة التنفيذ المحدثة (عملية)
- إنشاء الطبقات الثلاث (perception/policy/motor) كملفات منفصلة، وربطها بـ `scenario_runner`.
- إضافة `mouse_state` وإعادة ترتيب الحلقة (استكشف → اقترب → قيّم → قرر) داخل policy، مع مسارات تعافي عند `invalid_target`.
- نقل الحركة إلى motor الفيزيائي (سرعة منحنية، micro-corrections، jitter، hesitation).
- تفعيل استكشاف آمن واحد لكل صفحة مع تسجيل learned_events، يمكن تعطيله بـ `BGL_EXPLORATION`.
- تشغيل baseline واحد (home_index) لقياس move→click و click→DOM، ثم توثيق النتائج في `docs/logic_reference.md`.
- تطبيق معايير القبول (A وB) للتحقق قبل توسيع التشغيل إلى بقية السيناريوهات.

## 6) وصفة تشغيل قياسية (لتفادي الخلط مستقبلًا)
- للمراجعة البصرية (المتصفح ظاهر):
  ```
  $env:BGL_EXPLORATION=1
  python .bgl_core/brain/scenario_runner.py --headless 0 --keep-open 0 --max-pages 1 --idle-timeout 300 --base-url http://localhost:8000 --include basic_pages
  ```
- للمقاييس/CI (مخفي وسريع):
  ```
  $env:BGL_EXPLORATION=1
  python .bgl_core/brain/scenario_runner.py --headless 1 --keep-open 0 --max-pages 1 --idle-timeout 300 --base-url http://localhost:8000 --include basic_pages
  python .bgl_core/brain/metrics_summary.py
  python .bgl_core/brain/check_mouse_layer.py
  ```
- قاعدة التسمية: استخدم `--include <اسم السيناريو بدون .yaml>` فقط (مثال: basic_pages, index_search).
- سكربتات مساعدة مقترحة:
  - run_ui.ps1: ينفّذ أمر المراجعة البصرية.
  - run_ci.ps1: ينفّذ أمر القياس + metrics_summary + check_mouse_layer.

## 7) سياسة الرجوع (Back) والتبويب الجديد
- الرجوع داخل نفس التبويب يُسمح به فقط كتعافٍ عند حجب النقر (مودال يلتقط الأحداث) وبحد أقصى مرة واحدة لكل جلسة، مفعَّل فقط عند ضبط `BGL_ALLOW_BACK=1`. كل حدث BACK يُسجَّل في runtime_events كـ navigation_back.
- فتح تبويب جديد ممنوع في التشغيلات المرجعية (run_ui/run_ci). يُستخدم فقط كسيناريو تعافٍ استكشافي استثنائي ويُسجَّل صراحةً إذا فُعّل لاحقًا.

## 8) حالة التنفيذ الحالية وما تبقى
- الطبقات (Perception/Policy/Motor/hand_profile) والحارس (check_mouse_layer) مفعّلة.
- السيناريوهات التشغيلية: basic_pages، index_search، index_filters، dashboard_actions، dom_change؛ أوامر موحدة في run_ui.ps1 و run_ci.ps1.
- قياسات الحركة: move→click متوفرة، click→DOM تعمل الآن عبر MutationObserver مزروع قبل النقر (عند حدوث تغيير).
- ضبط السرعة/الجِتر/overshoot/hesitation يتم عبر متغيرات البيئة (`BGL_BASE_SPEED_MIN/MAX`, `BGL_JITTER_MIN/MAX`, `BGL_OVERSHOOT_MIN/MAX`, `BGL_HESITATION_MIN/MAX_MS`) بدون تعديل كود.
- حارس القياسات `metrics_guard.py` يقرأ `analysis/metrics_summary.json` ويتحقق من نطاق move→click (افتراضي 2000–6000ms) ويمكن إلزام وجود عينات DOM عبر `BGL_REQUIRE_DOM_CHANGE=1`.
- تحسينات إضافية (hand_profile أدق، سيناريوهات DOM أخرى، ضبط نطاقات الحارس) مسموحة لأي مطور طالما تبقى حركة الماوس عبر Motor والحارس مفعّلين.
